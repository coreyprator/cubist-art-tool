<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>{{ ui_title }}</title>
<style>
body{font-family:system-ui,Arial;margin:18px;background-color:#f8f9fa}
.card{background:white;padding:20px;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,0.1);margin-bottom:20px}
.row{margin-bottom:15px}
input[type=text]{width:520px;padding:8px;border:1px solid #ddd;border-radius:4px}
select{padding:8px;border:1px solid #ddd;border-radius:4px}
.button{padding:10px 16px;border-radius:6px;border:none;background:#007bff;color:#fff;cursor:pointer;font-weight:bold}
.button:hover{background:#0056b3}
.button.secondary{background:#6c757d}
.button.secondary:hover{background:#545b62}
.button.danger{background:#dc3545}
.button.danger:hover{background:#c82333}
.log{background:#111;color:#eee;padding:15px;height:300px;overflow:auto;font-family:'Courier New',monospace;border-radius:4px}
.preview{max-width:360px;max-height:200px;border:1px solid #444;border-radius:6px}
.points-input{width:100px;padding:8px;margin-right:8px;border:1px solid #ddd;border-radius:4px}
.error{color:#dc3545;font-size:12px;margin-top:4px}
.fill-method-section{background:#f8f9fa;padding:15px;border-radius:6px;border:1px solid #dee2e6}
.fill-method-option{margin-bottom:10px;padding:8px;border:1px solid #ddd;border-radius:4px;background:white}
.fill-method-option input[type=checkbox]{margin-right:8px}
.fill-method-description{font-size:12px;color:#666;margin-left:24px}
.status{margin:10px 0;font-weight:bold;padding:8px;border-radius:4px}
.status.idle{background:#d4edda;color:#155724}
.status.running{background:#cce7ff;color:#004085}

.geometry-card{background:#f8f9fa;border:1px solid #dee2e6;border-radius:6px;padding:15px;margin-bottom:15px}
.geometry-card-header{display:flex;align-items:center;margin-bottom:10px}
.geometry-card-header input[type=checkbox]{margin-right:10px;transform:scale(1.2)}
.geometry-card-header label{font-size:16px;font-weight:bold;margin:0;cursor:pointer}
.geometry-card.unchecked{opacity:0.5}
.geometry-card.unchecked .param-panel{pointer-events:none}

.param-panel{background:white;padding:15px;border-radius:6px;border:1px solid #dee2e6;margin-top:10px}
.param-panel-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;padding-bottom:8px;border-bottom:2px solid #007bff}
.param-panel-title{font-weight:bold;font-size:14px;color:#495057}
.param-row{display:grid;grid-template-columns:150px 1fr 80px;gap:10px;align-items:center;margin-bottom:12px}
.param-label{font-weight:500;font-size:13px}
.param-description{font-size:11px;color:#666;grid-column:1/4;margin-top:-8px;margin-bottom:8px}
.slider-container{display:flex;gap:8px;align-items:center}
.param-slider{flex:1;min-width:150px}
.param-text{width:70px;padding:4px 6px;border:1px solid #ddd;border-radius:3px;text-align:right;font-size:13px}
.param-text.invalid{border-color:#dc3545;background:#fee}

.hybrid-section{background:#fff3cd;padding:15px;border-radius:6px;border:2px solid #ffc107;margin-bottom:15px}
.hybrid-toggle{display:flex;align-items:center;margin-bottom:15px}
.hybrid-toggle input[type=checkbox]{margin-right:10px;transform:scale(1.3)}
.hybrid-toggle label{font-size:16px;font-weight:bold;color:#856404}
.hybrid-controls{display:none;padding:15px;background:white;border-radius:6px;margin-top:10px}
.hybrid-controls.active{display:block}
.mask-preview{max-width:200px;max-height:150px;border:1px solid #ddd;border-radius:4px;margin-top:8px}
.region-row{display:flex;align-items:center;gap:10px;padding:8px;background:#f8f9fa;border-radius:4px;margin-bottom:8px}
.region-color{width:30px;height:30px;border:1px solid #ddd;border-radius:4px}
</style>
</head>
<body>
<h1>{{ ui_title }}</h1>

<div class="card">
  <h3>Input Configuration</h3>
  <div class="row">
    <label><strong>Input image</strong></label><br/>
    <input id="input_image" type="text" placeholder="filename or absolute path"/>
    <div style="margin-top:6px">
      <select id="input_files_select" style="max-width:420px"></select>
      <button class="button" onclick="useSelected('input')">Use selected</button>
      <input id="file_input" type="file" style="margin-left:8px"/>
      <button class="button" onclick="uploadFile('input')">Upload</button>
    </div>
    <div style="margin-top:8px">
      <img id="input_preview" class="preview" src="" style="display:none"/>
      <div><a id="open_input_link" href="#" target="_blank" style="display:none">open image in new tab</a></div>
    </div>
  </div>

  <div class="row">
    <label><strong>Points</strong></label><br/>
    <input id="points" type="text" class="points-input" placeholder="e.g. 500" min="1" max="50000"/>
    <span style="color:#666;font-size:12px">Enter number of shapes (1-50000)</span>
    <div id="points-error" class="error" style="display:none"></div>
  </div>
</div>

<div class="card hybrid-section">
  <div class="hybrid-toggle">
    <input type="checkbox" id="hybrid_mode"/>
    <label for="hybrid_mode">Enable Hybrid Multi-Geometry Mode</label>
  </div>
  <div style="font-size:13px;color:#856404;margin-bottom:10px">
    Combine multiple geometries using mask-based regions (subject vs background)
  </div>
  
  <div id="hybrid_controls" class="hybrid-controls">
    <div class="row">
      <label><strong>Mask Image</strong> (defines subject vs background)</label><br/>
      <small style="color:#666">White/light areas (128-255) = Subject | Black/dark areas (0-127) = Background</small><br/>
      <select id="mask_files_select" style="max-width:420px;margin-top:6px"></select>
      <button class="button secondary" onclick="useSelected('mask')">Use selected</button>
      <input id="mask_file_input" type="file" style="margin-left:8px"/>
      <button class="button secondary" onclick="uploadFile('mask')">Upload</button>
      <div style="margin-top:8px">
        <img id="mask_preview" class="mask-preview" src="" style="display:none"/>
        <div id="mask_info" style="font-size:12px;color:#666;margin-top:4px"></div>
      </div>
    </div>
    
    <div class="row">
      <label><strong>Background Image</strong> (optional - for background color source)</label><br/>
      <small style="color:#666">If not provided, background samples from input image</small><br/>
      <select id="background_files_select" style="max-width:420px;margin-top:6px"></select>
      <button class="button secondary" onclick="useSelected('background')">Use selected</button>
      <input id="background_file_input" type="file" style="margin-left:8px"/>
      <button class="button secondary" onclick="uploadFile('background')">Upload</button>
      <div style="margin-top:8px">
        <img id="background_preview" class="preview" src="" style="display:none"/>
      </div>
    </div>
    
    <div id="region_assignments" style="margin-top:15px;display:none">
      <h4>Region Assignments</h4>
      <div style="font-size:12px;color:#666;margin-bottom:10px">
        Assign different geometries to subject and background
      </div>
      <div id="region_list"></div>
    </div>
  </div>
</div>

<div class="card">
  <h3>Fill Methods</h3>
  <div class="fill-method-section">
    <div class="fill-method-option">
      <label>
        <input type="checkbox" name="fill_method" value="default" checked/>
        <strong>Default Fill</strong>
      </label>
      <div class="fill-method-description">Base shapes only</div>
    </div>
    <div class="fill-method-option">
      <label>
        <input type="checkbox" name="fill_method" value="cascade"/>
        <strong>Cascade Fill</strong>
      </label>
      <div class="fill-method-description">Base shapes + gap filling</div>
    </div>
  </div>
</div>

<div class="card">
  <h3>Geometries & Parameters</h3>
  <div id="geometry-cards"></div>
  <div style="margin-top:15px">
    <button class="button danger" onclick="factoryReset()">Factory Reset All Parameters</button>
  </div>
</div>

<div class="card">
  <h3>Execution</h3>
  <div class="row">
    <label><input id="auto_open" type="checkbox" checked/> <strong>Auto-open gallery</strong></label>
    <label style="margin-left:20px"><input id="verbose" type="checkbox"/> <strong>Verbose logging</strong></label>
  </div>

  <div class="row">
    <button class="button" id="run_btn" onclick="runBatch()">Run Batch</button>
    <button class="button secondary" onclick="clearLog()">Clear Log</button>
    <button class="button secondary" onclick="copyLog()">Copy Log</button>
  </div>

  <div id="status" class="status idle">Status: Idle</div>
</div>

<div class="card">
  <h3>Execution Log</h3>
  <div id="log" class="log"></div>
</div>

<script>
const geoms = {{ geoms_json|safe }};
const GEOMETRY_PARAMETERS = {{ geom_params_json|safe }};

// Hybrid mode toggle
document.getElementById('hybrid_mode').addEventListener('change', function() {
  const controls = document.getElementById('hybrid_controls');
  if (this.checked) {
    controls.classList.add('active');
  } else {
    controls.classList.remove('active');
  }
  savePrefs();
});

// Mask upload triggers region detection
document.getElementById('mask_file_input').addEventListener('change', async function() {
  if (this.files && this.files[0]) {
    const formData = new FormData();
    formData.append('file', this.files[0]);
    const response = await fetch('/upload?type=mask', {method: 'POST', body: formData});
    const result = await response.json();
    
    if (result.filename) {
      document.getElementById('mask_files_select').value = result.filename;
      await useSelected('mask');
      
      // Detect regions
      if (result.regions) {
        showRegionAssignments(result.regions);
      }
    }
  }
});

function showRegionAssignments(regions) {
  const container = document.getElementById('region_assignments');
  const list = document.getElementById('region_list');
  
  list.innerHTML = '';
  
  regions.forEach(region => {
    const row = document.createElement('div');
    row.className = 'region-row';
    row.innerHTML = `
      <div class="region-color" style="background:rgb(${region.value},${region.value},${region.value})"></div>
      <strong>Region ${region.value}</strong>
      <span>(${region.percentage}% of canvas)</span>
      <select class="region-geometry" data-region="${region.value}">
        ${geoms.map(g => `<option value="${g}">${g}</option>`).join('')}
      </select>
      <input type="number" class="points-input" placeholder="shapes" value="${Math.round(region.percentage * 5)}" 
             data-region="${region.value}" style="width:80px"/>
    `;
    list.appendChild(row);
  });
  
  container.style.display = 'block';
}

function createGeometryCard(geom, defaultChecked) {
  const params = GEOMETRY_PARAMETERS[geom];
  
  let paramRows = '';
  if (params && Object.keys(params).length > 0) {
    for (const [paramName, paramDef] of Object.entries(params)) {
      const sliderId = `slider_${geom}_${paramName}`;
      const textId = `text_${geom}_${paramName}`;
      
      paramRows += `
        <div class="param-row">
          <div class="param-label">${paramDef.label}:</div>
          <div class="slider-container">
            <input type="range" 
              class="param-slider" 
              id="${sliderId}"
              min="${paramDef.min}" 
              max="${paramDef.max}" 
              step="${paramDef.step}" 
              value="${paramDef.default}"
              oninput="syncSliderToText('${geom}', '${paramName}')"/>
            <input type="text" 
              class="param-text" 
              id="${textId}"
              value="${paramDef.default}"
              onchange="syncTextToSlider('${geom}', '${paramName}')"/>
          </div>
        </div>
        <div class="param-description">${paramDef.description}</div>
      `;
    }
  }

  const paramPanel = paramRows ? `
    <div class="param-panel">
      <div class="param-panel-header">
        <div class="param-panel-title">Parameters</div>
        <button class="button secondary" style="font-size:11px;padding:4px 8px" onclick="resetGeometryParams('${geom}')">Reset</button>
      </div>
      ${paramRows}
    </div>
  ` : '<div style="padding:10px;color:#666;font-size:13px">No configurable parameters</div>';

  return `
    <div class="geometry-card ${defaultChecked ? '' : 'unchecked'}" id="card_${geom}">
      <div class="geometry-card-header">
        <input type="checkbox" id="geom_${geom}" ${defaultChecked ? 'checked' : ''} onchange="updateGeometryCard('${geom}')"/>
        <label for="geom_${geom}">${geom}</label>
      </div>
      ${paramPanel}
    </div>
  `;
}

function updateGeometryCard(geom) {
  const checkbox = document.getElementById(`geom_${geom}`);
  const card = document.getElementById(`card_${geom}`);
  
  if (checkbox && card) {
    if (checkbox.checked) {
      card.classList.remove('unchecked');
    } else {
      card.classList.add('unchecked');
    }
  }
  
  savePrefs();
}

function initGeometryCards() {
  const container = document.getElementById('geometry-cards');
  let html = '';
  
  geoms.forEach((geom, index) => {
    html += createGeometryCard(geom, index < 3);
  });
  
  container.innerHTML = html;
}

function syncSliderToText(geom, paramName) {
  const slider = document.getElementById(`slider_${geom}_${paramName}`);
  const text = document.getElementById(`text_${geom}_${paramName}`);
  text.value = slider.value;
  text.classList.remove('invalid');
  savePrefs();
}

function syncTextToSlider(geom, paramName) {
  const slider = document.getElementById(`slider_${geom}_${paramName}`);
  const text = document.getElementById(`text_${geom}_${paramName}`);
  const paramDef = GEOMETRY_PARAMETERS[geom][paramName];
  
  const value = parseFloat(text.value);
  if (isNaN(value)) {
    text.classList.add('invalid');
    return;
  }
  
  if (value < paramDef.min || value > paramDef.max) {
    text.classList.add('invalid');
    return;
  }
  
  text.classList.remove('invalid');
  slider.value = value;
  savePrefs();
}

function resetGeometryParams(geom) {
  const params = GEOMETRY_PARAMETERS[geom];
  for (const [paramName, paramDef] of Object.entries(params)) {
    const slider = document.getElementById(`slider_${geom}_${paramName}`);
    const text = document.getElementById(`text_${geom}_${paramName}`);
    if (slider && text) {
      slider.value = paramDef.default;
      text.value = paramDef.default;
      text.classList.remove('invalid');
    }
  }
  savePrefs();
  alert(`${geom} parameters reset to factory defaults`);
}

function factoryReset() {
  if (!confirm('Reset ALL geometry parameters to factory defaults?')) return;
  
  geoms.forEach(geom => {
    const params = GEOMETRY_PARAMETERS[geom];
    if (!params) return;
    for (const [paramName, paramDef] of Object.entries(params)) {
      const slider = document.getElementById(`slider_${geom}_${paramName}`);
      const text = document.getElementById(`text_${geom}_${paramName}`);
      if (slider && text) {
        slider.value = paramDef.default;
        text.value = paramDef.default;
        text.classList.remove('invalid');
      }
    }
  });
  
  savePrefs();
  alert('All parameters reset to factory defaults');
}

function getGeometryParameters() {
  const result = {};
  geoms.forEach(geom => {
    const params = GEOMETRY_PARAMETERS[geom];
    if (!params) return;
    
    const geomParams = {};
    for (const paramName of Object.keys(params)) {
      const text = document.getElementById(`text_${geom}_${paramName}`);
      if (text && !text.classList.contains('invalid')) {
        geomParams[paramName] = parseFloat(text.value);
      }
    }
    result[geom] = geomParams;
  });
  return result;
}

function validatePoints(value) {
  const num = parseInt(value);
  if (isNaN(num)) return { valid: false, error: 'Must be a number' };
  if (num < 1) return { valid: false, error: 'Must be at least 1' };
  if (num > 50000) return { valid: false, error: 'Must be 50000 or less' };
  return { valid: true, value: num };
}

function updatePointsValidation() {
  const input = document.getElementById('points');
  const errorDiv = document.getElementById('points-error');
  const runBtn = document.getElementById('run_btn');

  const validation = validatePoints(input.value);

  if (validation.valid) {
    input.style.borderColor = '';
    errorDiv.style.display = 'none';
    runBtn.disabled = false;
    savePrefs();
  } else {
    input.style.borderColor = '#dc3545';
    errorDiv.textContent = validation.error;
    errorDiv.style.display = 'block';
    runBtn.disabled = true;
  }
}

async function loadInputFiles(){
  try{
    const res = await fetch('/input_files');
    const files = await res.json();
    
    // Populate all three selectors
    ['input', 'mask', 'background'].forEach(type => {
      const sel = document.getElementById(`${type}_files_select`);
      sel.innerHTML = '';
      files.forEach(f=>{
        const o = document.createElement('option'); 
        o.value = f; 
        o.text = f; 
        sel.appendChild(o);
      });
    });
  }catch(e){ console.warn(e); }
}

function setInputPreview(path, type='input'){
  const img = document.getElementById(`${type}_preview`);
  const link = document.getElementById(`open_${type}_link`);
  
  if(!path){ 
    img.style.display='none'; 
    img.src=''; 
    if(link) link.style.display='none'; 
    return; 
  }
  
  const url = '/preview?file=' + encodeURIComponent(path);
  img.src = url; 
  img.style.display = 'inline-block'; 
  if(link) {
    link.href = url; 
    link.style.display='inline';
  }
}

function useSelected(type){
  const sel = document.getElementById(`${type}_files_select`);
  if(!sel.value) return;
  
  if (type === 'input') {
    document.getElementById('input_image').value = sel.value;
  }
  
  setInputPreview(sel.value, type);
  savePrefs();
}

async function uploadFile(type){
  const inp = document.getElementById(`${type === 'input' ? 'file_input' : type + '_file_input'}`);
  if(!inp.files || inp.files.length===0){ alert('Select file'); return; }
  
  const fd = new FormData(); 
  fd.append('file', inp.files[0]);
  const r = await fetch(`/upload?type=${type}`,{method:'POST', body:fd});
  const j = await r.json();
  
  if(r.ok && j.filename){
    await loadInputFiles();
    document.getElementById(`${type}_files_select`).value = j.filename;
    await useSelected(type);
    
    // If mask uploaded, detect regions
    if (type === 'mask' && j.regions) {
      showRegionAssignments(j.regions);
    }
  } else {
    alert('Upload failed: ' + (j.error || 'unknown'));
  }
}

function clearLog(){ document.getElementById('log').innerHTML = ''; }

function copyLog(){
  navigator.clipboard.writeText(document.getElementById('log').innerText).then(
    ()=>{ alert('Log copied') },
    ()=> alert('Copy failed')
  );
}

function getSelectedFillMethods() {
  const checkboxes = document.querySelectorAll('input[name="fill_method"]:checked');
  return Array.from(checkboxes).map(cb => cb.value);
}

function getRegionAssignments() {
  const assignments = {};
  
  document.querySelectorAll('.region-geometry').forEach(select => {
    const region = select.dataset.region;
    const geometry = select.value;
    const pointsInput = document.querySelector(`input[data-region="${region}"]`);
    const points = parseInt(pointsInput.value) || 100;
    
    assignments[region] = {
      geometry: geometry,
      target_count: points,
      params: getGeometryParameters()[geometry] || {}
    };
  });
  
  return assignments;
}

async function savePrefs(obj){
  try{
    const pointsValidation = validatePoints(document.getElementById('points').value);
    const base = {
      input_image: document.getElementById('input_image').value,
      mask_image: document.getElementById('mask_files_select')?.value || '',
      background_image: document.getElementById('background_files_select')?.value || '',
      points: pointsValidation.valid ? pointsValidation.value : 500,
      geoms: Array.from(geoms).filter(g=>document.getElementById('geom_'+g).checked),
      auto_open_gallery: document.getElementById('auto_open').checked,
      verbose_probe: document.getElementById('verbose').checked,
      fill_methods: getSelectedFillMethods(),
      geometry_parameters: getGeometryParameters(),
      hybrid_mode: document.getElementById('hybrid_mode').checked,
      region_assignments: getRegionAssignments()
    };
    const payload = Object.assign(base, obj||{});
    await fetch('/save_prefs',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
  }catch(e){ console.warn('savePrefs', e); }
}

document.addEventListener('DOMContentLoaded', async ()=>{
  document.getElementById('points').addEventListener('input', updatePointsValidation);
  document.getElementById('points').addEventListener('blur', updatePointsValidation);

  await loadInputFiles();
  initGeometryCards();

  document.getElementById('auto_open').addEventListener('change', ()=> savePrefs());
  document.getElementById('verbose').addEventListener('change', ()=> savePrefs());

  document.querySelectorAll('input[name="fill_method"]').forEach(checkbox => {
    checkbox.addEventListener('change', () => savePrefs());
  });

  try{
    const p = await (await fetch('/prefs')).json();
    if(p.input_image) document.getElementById('input_image').value = p.input_image;
    if(p.points) document.getElementById('points').value = p.points;
    
    if(Array.isArray(p.geoms)){
      geoms.forEach(g=>{ 
        const el=document.getElementById('geom_'+g); 
        if(el) el.checked = p.geoms.includes(g); 
      });
    }
    
    document.getElementById('auto_open').checked = p.auto_open_gallery !== false;
    document.getElementById('verbose').checked = !!(p.verbose_probe || p.verbose);
    document.getElementById('hybrid_mode').checked = !!p.hybrid_mode;

    if(Array.isArray(p.fill_methods)){
      p.fill_methods.forEach(method => {
        const checkbox = document.querySelector(`input[name="fill_method"][value="${method}"]`);
        if(checkbox) checkbox.checked = true;
      });
    }

    if(p.geometry_parameters){
      geoms.forEach(geom => {
        const savedParams = p.geometry_parameters[geom];
        if(savedParams){
          for(const [paramName, value] of Object.entries(savedParams)){
            const slider = document.getElementById(`slider_${geom}_${paramName}`);
            const text = document.getElementById(`text_${geom}_${paramName}`);
            if(slider && text){
              slider.value = value;
              text.value = value;
            }
          }
        }
      });
    }

    setInputPreview(p.input_image || '', 'input');
    
    if(p.mask_image) {
      document.getElementById('mask_files_select').value = p.mask_image;
      setInputPreview(p.mask_image, 'mask');
    }
    
    if(p.background_image) {
      document.getElementById('background_files_select').value = p.background_image;
      setInputPreview(p.background_image, 'background');
    }
    
    if(p.hybrid_mode) {
      document.getElementById('hybrid_controls').classList.add('active');
      
      // AUTO-LOAD REGION UI FIX: Detect regions and restore assignments
      if(p.mask_image) {
        try {
          const response = await fetch('/detect_regions?file=' + encodeURIComponent(p.mask_image));
          const data = await response.json();
          
          if(data.regions && data.regions.length > 0) {
            showRegionAssignments(data.regions);
            
            // Restore saved region assignments
            if(p.region_assignments && Object.keys(p.region_assignments).length > 0) {
              // Wait for DOM to update
              setTimeout(() => {
                Object.keys(p.region_assignments).forEach(regionId => {
                  const assignment = p.region_assignments[regionId];
                  const geomSelect = document.querySelector(`.region-geometry[data-region="${regionId}"]`);
                  const pointsInput = document.querySelector(`input.points-input[data-region="${regionId}"]`);
                  
                  if(geomSelect && assignment.geometry) {
                    geomSelect.value = assignment.geometry;
                  }
                  if(pointsInput && assignment.target_count) {
                    pointsInput.value = assignment.target_count;
                  }
                });
              }, 100);
            }
          }
        } catch(err) {
          console.warn('Auto-detect regions failed:', err);
        }
      }
    }
    
    updatePointsValidation();
    
    geoms.forEach(geom => {
      const checkbox = document.getElementById(`geom_${geom}`);
      const card = document.getElementById(`card_${geom}`);
      if (checkbox && card && !checkbox.checked) {
        card.classList.add('unchecked');
      }
    });
  }catch(e){ console.warn('prefs load', e); }
});

async function runBatch(){
  const inputImage = document.getElementById('input_image').value.trim();
  if(!inputImage){ alert('Specify input'); return; }

  const pointsValidation = validatePoints(document.getElementById('points').value);
  if(!pointsValidation.valid){
    alert('Invalid points value: ' + pointsValidation.error);
    return;
  }

  const selected = geoms.filter(g=>document.getElementById('geom_'+g).checked);
  if(selected.length===0){ alert('Select at least one geometry'); return; }

  const fillMethods = getSelectedFillMethods();
  if(fillMethods.length===0){ alert('Select at least one fill method'); return; }
  
  const hybridMode = document.getElementById('hybrid_mode').checked;
  let maskImage = '';
  let backgroundImage = '';
  let regionAssignments = {};
  
  if (hybridMode) {
    maskImage = document.getElementById('mask_files_select')?.value || '';
    backgroundImage = document.getElementById('background_files_select')?.value || '';
    
    if (!maskImage) {
      alert('Hybrid mode requires a mask image');
      return;
    }
    
    regionAssignments = getRegionAssignments();
    
    if (Object.keys(regionAssignments).length === 0) {
      alert('Hybrid mode requires region assignments');
      return;
    }
  }

  let hasInvalidParams = false;
  geoms.forEach(geom => {
    const params = GEOMETRY_PARAMETERS[geom];
    if(!params) return;
    for(const paramName of Object.keys(params)){
      const text = document.getElementById(`text_${geom}_${paramName}`);
      if(text && text.classList.contains('invalid')){
        hasInvalidParams = true;
      }
    }
  });

  if(hasInvalidParams){
    alert('Some parameter values are invalid. Please correct them before running.');
    return;
  }

  const payload = {
    input_image: inputImage,
    points: pointsValidation.value,
    seed: 42,
    geoms: selected,
    fill_methods: fillMethods,
    geometry_parameters: getGeometryParameters(),
    auto_open: document.getElementById('auto_open').checked,
    verbose: document.getElementById('verbose').checked,
    hybrid_mode: hybridMode,
    mask_image: maskImage,
    background_image: backgroundImage,
    region_assignments: regionAssignments
  };

  await fetch('/run_batch',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
}

setInterval(async ()=>{
  try{
    const st = await (await fetch('/status')).json();
    const statusEl = document.getElementById('status');
    if(st.busy) {
      statusEl.textContent = 'Status: Running...';
      statusEl.className = 'status running';
    } else {
      statusEl.textContent = 'Status: Idle';
      statusEl.className = 'status idle';
    }

    const logs = await (await fetch('/logs')).json();
    if(Array.isArray(logs) && logs.length){
      const container = document.getElementById('log');
      logs.forEach(h=>{ const d=document.createElement('div'); d.innerHTML = h; container.appendChild(d); });
      container.scrollTop = container.scrollHeight;
    }
  }catch(e){ /* ignore */ }
}, 1000);
</script>
</body>
</html>